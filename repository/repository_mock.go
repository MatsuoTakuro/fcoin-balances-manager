// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"context"
	"github.com/MatsuoTakuro/fcoin-balances-manager/entity"
	"sync"
)

// Ensure, that UserRegisterRepoMock does implement UserRegisterRepo.
// If this is not the case, regenerate this file with moq.
var _ UserRegisterRepo = &UserRegisterRepoMock{}

// UserRegisterRepoMock is a mock implementation of UserRegisterRepo.
//
//	func TestSomethingThatUsesUserRegisterRepo(t *testing.T) {
//
//		// make and configure a mocked UserRegisterRepo
//		mockedUserRegisterRepo := &UserRegisterRepoMock{
//			RegisterUserTxFunc: func(ctx context.Context, db Beginner, name string) (*entity.User, *entity.Balance, error) {
//				panic("mock out the RegisterUserTx method")
//			},
//		}
//
//		// use mockedUserRegisterRepo in code that requires UserRegisterRepo
//		// and then make assertions.
//
//	}
type UserRegisterRepoMock struct {
	// RegisterUserTxFunc mocks the RegisterUserTx method.
	RegisterUserTxFunc func(ctx context.Context, db Beginner, name string) (*entity.User, *entity.Balance, error)

	// calls tracks calls to the methods.
	calls struct {
		// RegisterUserTx holds details about calls to the RegisterUserTx method.
		RegisterUserTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Beginner
			// Name is the name argument value.
			Name string
		}
	}
	lockRegisterUserTx sync.RWMutex
}

// RegisterUserTx calls RegisterUserTxFunc.
func (mock *UserRegisterRepoMock) RegisterUserTx(ctx context.Context, db Beginner, name string) (*entity.User, *entity.Balance, error) {
	if mock.RegisterUserTxFunc == nil {
		panic("UserRegisterRepoMock.RegisterUserTxFunc: method is nil but UserRegisterRepo.RegisterUserTx was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Db   Beginner
		Name string
	}{
		Ctx:  ctx,
		Db:   db,
		Name: name,
	}
	mock.lockRegisterUserTx.Lock()
	mock.calls.RegisterUserTx = append(mock.calls.RegisterUserTx, callInfo)
	mock.lockRegisterUserTx.Unlock()
	return mock.RegisterUserTxFunc(ctx, db, name)
}

// RegisterUserTxCalls gets all the calls that were made to RegisterUserTx.
// Check the length with:
//
//	len(mockedUserRegisterRepo.RegisterUserTxCalls())
func (mock *UserRegisterRepoMock) RegisterUserTxCalls() []struct {
	Ctx  context.Context
	Db   Beginner
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Db   Beginner
		Name string
	}
	mock.lockRegisterUserTx.RLock()
	calls = mock.calls.RegisterUserTx
	mock.lockRegisterUserTx.RUnlock()
	return calls
}

// Ensure, that BalanceUpdaterRepoMock does implement BalanceUpdaterRepo.
// If this is not the case, regenerate this file with moq.
var _ BalanceUpdaterRepo = &BalanceUpdaterRepoMock{}

// BalanceUpdaterRepoMock is a mock implementation of BalanceUpdaterRepo.
//
//	func TestSomethingThatUsesBalanceUpdaterRepo(t *testing.T) {
//
//		// make and configure a mocked BalanceUpdaterRepo
//		mockedBalanceUpdaterRepo := &BalanceUpdaterRepoMock{
//			GetBalanceByUserIDFunc: func(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error) {
//				panic("mock out the GetBalanceByUserID method")
//			},
//			UpdateBalanceTxFunc: func(ctx context.Context, db Beginner, balance *entity.Balance, amount int32) (*entity.BalanceTrans, error) {
//				panic("mock out the UpdateBalanceTx method")
//			},
//		}
//
//		// use mockedBalanceUpdaterRepo in code that requires BalanceUpdaterRepo
//		// and then make assertions.
//
//	}
type BalanceUpdaterRepoMock struct {
	// GetBalanceByUserIDFunc mocks the GetBalanceByUserID method.
	GetBalanceByUserIDFunc func(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error)

	// UpdateBalanceTxFunc mocks the UpdateBalanceTx method.
	UpdateBalanceTxFunc func(ctx context.Context, db Beginner, balance *entity.Balance, amount int32) (*entity.BalanceTrans, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetBalanceByUserID holds details about calls to the GetBalanceByUserID method.
		GetBalanceByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Queryer
			// UserID is the userID argument value.
			UserID entity.UserID
		}
		// UpdateBalanceTx holds details about calls to the UpdateBalanceTx method.
		UpdateBalanceTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Beginner
			// Balance is the balance argument value.
			Balance *entity.Balance
			// Amount is the amount argument value.
			Amount int32
		}
	}
	lockGetBalanceByUserID sync.RWMutex
	lockUpdateBalanceTx    sync.RWMutex
}

// GetBalanceByUserID calls GetBalanceByUserIDFunc.
func (mock *BalanceUpdaterRepoMock) GetBalanceByUserID(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error) {
	if mock.GetBalanceByUserIDFunc == nil {
		panic("BalanceUpdaterRepoMock.GetBalanceByUserIDFunc: method is nil but BalanceUpdaterRepo.GetBalanceByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     Queryer
		UserID entity.UserID
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetBalanceByUserID.Lock()
	mock.calls.GetBalanceByUserID = append(mock.calls.GetBalanceByUserID, callInfo)
	mock.lockGetBalanceByUserID.Unlock()
	return mock.GetBalanceByUserIDFunc(ctx, db, userID)
}

// GetBalanceByUserIDCalls gets all the calls that were made to GetBalanceByUserID.
// Check the length with:
//
//	len(mockedBalanceUpdaterRepo.GetBalanceByUserIDCalls())
func (mock *BalanceUpdaterRepoMock) GetBalanceByUserIDCalls() []struct {
	Ctx    context.Context
	Db     Queryer
	UserID entity.UserID
} {
	var calls []struct {
		Ctx    context.Context
		Db     Queryer
		UserID entity.UserID
	}
	mock.lockGetBalanceByUserID.RLock()
	calls = mock.calls.GetBalanceByUserID
	mock.lockGetBalanceByUserID.RUnlock()
	return calls
}

// UpdateBalanceTx calls UpdateBalanceTxFunc.
func (mock *BalanceUpdaterRepoMock) UpdateBalanceTx(ctx context.Context, db Beginner, balance *entity.Balance, amount int32) (*entity.BalanceTrans, error) {
	if mock.UpdateBalanceTxFunc == nil {
		panic("BalanceUpdaterRepoMock.UpdateBalanceTxFunc: method is nil but BalanceUpdaterRepo.UpdateBalanceTx was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Db      Beginner
		Balance *entity.Balance
		Amount  int32
	}{
		Ctx:     ctx,
		Db:      db,
		Balance: balance,
		Amount:  amount,
	}
	mock.lockUpdateBalanceTx.Lock()
	mock.calls.UpdateBalanceTx = append(mock.calls.UpdateBalanceTx, callInfo)
	mock.lockUpdateBalanceTx.Unlock()
	return mock.UpdateBalanceTxFunc(ctx, db, balance, amount)
}

// UpdateBalanceTxCalls gets all the calls that were made to UpdateBalanceTx.
// Check the length with:
//
//	len(mockedBalanceUpdaterRepo.UpdateBalanceTxCalls())
func (mock *BalanceUpdaterRepoMock) UpdateBalanceTxCalls() []struct {
	Ctx     context.Context
	Db      Beginner
	Balance *entity.Balance
	Amount  int32
} {
	var calls []struct {
		Ctx     context.Context
		Db      Beginner
		Balance *entity.Balance
		Amount  int32
	}
	mock.lockUpdateBalanceTx.RLock()
	calls = mock.calls.UpdateBalanceTx
	mock.lockUpdateBalanceTx.RUnlock()
	return calls
}

// Ensure, that CoinsTransferRepoMock does implement CoinsTransferRepo.
// If this is not the case, regenerate this file with moq.
var _ CoinsTransferRepo = &CoinsTransferRepoMock{}

// CoinsTransferRepoMock is a mock implementation of CoinsTransferRepo.
//
//	func TestSomethingThatUsesCoinsTransferRepo(t *testing.T) {
//
//		// make and configure a mocked CoinsTransferRepo
//		mockedCoinsTransferRepo := &CoinsTransferRepoMock{
//			GetBalanceByUserIDFunc: func(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error) {
//				panic("mock out the GetBalanceByUserID method")
//			},
//			TransferCoinsTxFunc: func(ctx context.Context, db Beginner, fromBalance *entity.Balance, toBalance *entity.Balance, amount uint32) (*entity.BalanceTrans, error) {
//				panic("mock out the TransferCoinsTx method")
//			},
//		}
//
//		// use mockedCoinsTransferRepo in code that requires CoinsTransferRepo
//		// and then make assertions.
//
//	}
type CoinsTransferRepoMock struct {
	// GetBalanceByUserIDFunc mocks the GetBalanceByUserID method.
	GetBalanceByUserIDFunc func(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error)

	// TransferCoinsTxFunc mocks the TransferCoinsTx method.
	TransferCoinsTxFunc func(ctx context.Context, db Beginner, fromBalance *entity.Balance, toBalance *entity.Balance, amount uint32) (*entity.BalanceTrans, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetBalanceByUserID holds details about calls to the GetBalanceByUserID method.
		GetBalanceByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Queryer
			// UserID is the userID argument value.
			UserID entity.UserID
		}
		// TransferCoinsTx holds details about calls to the TransferCoinsTx method.
		TransferCoinsTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Beginner
			// FromBalance is the fromBalance argument value.
			FromBalance *entity.Balance
			// ToBalance is the toBalance argument value.
			ToBalance *entity.Balance
			// Amount is the amount argument value.
			Amount uint32
		}
	}
	lockGetBalanceByUserID sync.RWMutex
	lockTransferCoinsTx    sync.RWMutex
}

// GetBalanceByUserID calls GetBalanceByUserIDFunc.
func (mock *CoinsTransferRepoMock) GetBalanceByUserID(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error) {
	if mock.GetBalanceByUserIDFunc == nil {
		panic("CoinsTransferRepoMock.GetBalanceByUserIDFunc: method is nil but CoinsTransferRepo.GetBalanceByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     Queryer
		UserID entity.UserID
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetBalanceByUserID.Lock()
	mock.calls.GetBalanceByUserID = append(mock.calls.GetBalanceByUserID, callInfo)
	mock.lockGetBalanceByUserID.Unlock()
	return mock.GetBalanceByUserIDFunc(ctx, db, userID)
}

// GetBalanceByUserIDCalls gets all the calls that were made to GetBalanceByUserID.
// Check the length with:
//
//	len(mockedCoinsTransferRepo.GetBalanceByUserIDCalls())
func (mock *CoinsTransferRepoMock) GetBalanceByUserIDCalls() []struct {
	Ctx    context.Context
	Db     Queryer
	UserID entity.UserID
} {
	var calls []struct {
		Ctx    context.Context
		Db     Queryer
		UserID entity.UserID
	}
	mock.lockGetBalanceByUserID.RLock()
	calls = mock.calls.GetBalanceByUserID
	mock.lockGetBalanceByUserID.RUnlock()
	return calls
}

// TransferCoinsTx calls TransferCoinsTxFunc.
func (mock *CoinsTransferRepoMock) TransferCoinsTx(ctx context.Context, db Beginner, fromBalance *entity.Balance, toBalance *entity.Balance, amount uint32) (*entity.BalanceTrans, error) {
	if mock.TransferCoinsTxFunc == nil {
		panic("CoinsTransferRepoMock.TransferCoinsTxFunc: method is nil but CoinsTransferRepo.TransferCoinsTx was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Db          Beginner
		FromBalance *entity.Balance
		ToBalance   *entity.Balance
		Amount      uint32
	}{
		Ctx:         ctx,
		Db:          db,
		FromBalance: fromBalance,
		ToBalance:   toBalance,
		Amount:      amount,
	}
	mock.lockTransferCoinsTx.Lock()
	mock.calls.TransferCoinsTx = append(mock.calls.TransferCoinsTx, callInfo)
	mock.lockTransferCoinsTx.Unlock()
	return mock.TransferCoinsTxFunc(ctx, db, fromBalance, toBalance, amount)
}

// TransferCoinsTxCalls gets all the calls that were made to TransferCoinsTx.
// Check the length with:
//
//	len(mockedCoinsTransferRepo.TransferCoinsTxCalls())
func (mock *CoinsTransferRepoMock) TransferCoinsTxCalls() []struct {
	Ctx         context.Context
	Db          Beginner
	FromBalance *entity.Balance
	ToBalance   *entity.Balance
	Amount      uint32
} {
	var calls []struct {
		Ctx         context.Context
		Db          Beginner
		FromBalance *entity.Balance
		ToBalance   *entity.Balance
		Amount      uint32
	}
	mock.lockTransferCoinsTx.RLock()
	calls = mock.calls.TransferCoinsTx
	mock.lockTransferCoinsTx.RUnlock()
	return calls
}

// Ensure, that BalanceDetailsGetterRepoMock does implement BalanceDetailsGetterRepo.
// If this is not the case, regenerate this file with moq.
var _ BalanceDetailsGetterRepo = &BalanceDetailsGetterRepoMock{}

// BalanceDetailsGetterRepoMock is a mock implementation of BalanceDetailsGetterRepo.
//
//	func TestSomethingThatUsesBalanceDetailsGetterRepo(t *testing.T) {
//
//		// make and configure a mocked BalanceDetailsGetterRepo
//		mockedBalanceDetailsGetterRepo := &BalanceDetailsGetterRepoMock{
//			GetBalanceByUserIDFunc: func(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error) {
//				panic("mock out the GetBalanceByUserID method")
//			},
//			GetBalanceTransListByBalanceIDFunc: func(ctx context.Context, db Queryer, balanceID entity.BalanceID) ([]*entity.BalanceTrans, error) {
//				panic("mock out the GetBalanceTransListByBalanceID method")
//			},
//		}
//
//		// use mockedBalanceDetailsGetterRepo in code that requires BalanceDetailsGetterRepo
//		// and then make assertions.
//
//	}
type BalanceDetailsGetterRepoMock struct {
	// GetBalanceByUserIDFunc mocks the GetBalanceByUserID method.
	GetBalanceByUserIDFunc func(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error)

	// GetBalanceTransListByBalanceIDFunc mocks the GetBalanceTransListByBalanceID method.
	GetBalanceTransListByBalanceIDFunc func(ctx context.Context, db Queryer, balanceID entity.BalanceID) ([]*entity.BalanceTrans, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetBalanceByUserID holds details about calls to the GetBalanceByUserID method.
		GetBalanceByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Queryer
			// UserID is the userID argument value.
			UserID entity.UserID
		}
		// GetBalanceTransListByBalanceID holds details about calls to the GetBalanceTransListByBalanceID method.
		GetBalanceTransListByBalanceID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db Queryer
			// BalanceID is the balanceID argument value.
			BalanceID entity.BalanceID
		}
	}
	lockGetBalanceByUserID             sync.RWMutex
	lockGetBalanceTransListByBalanceID sync.RWMutex
}

// GetBalanceByUserID calls GetBalanceByUserIDFunc.
func (mock *BalanceDetailsGetterRepoMock) GetBalanceByUserID(ctx context.Context, db Queryer, userID entity.UserID) (*entity.Balance, error) {
	if mock.GetBalanceByUserIDFunc == nil {
		panic("BalanceDetailsGetterRepoMock.GetBalanceByUserIDFunc: method is nil but BalanceDetailsGetterRepo.GetBalanceByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Db     Queryer
		UserID entity.UserID
	}{
		Ctx:    ctx,
		Db:     db,
		UserID: userID,
	}
	mock.lockGetBalanceByUserID.Lock()
	mock.calls.GetBalanceByUserID = append(mock.calls.GetBalanceByUserID, callInfo)
	mock.lockGetBalanceByUserID.Unlock()
	return mock.GetBalanceByUserIDFunc(ctx, db, userID)
}

// GetBalanceByUserIDCalls gets all the calls that were made to GetBalanceByUserID.
// Check the length with:
//
//	len(mockedBalanceDetailsGetterRepo.GetBalanceByUserIDCalls())
func (mock *BalanceDetailsGetterRepoMock) GetBalanceByUserIDCalls() []struct {
	Ctx    context.Context
	Db     Queryer
	UserID entity.UserID
} {
	var calls []struct {
		Ctx    context.Context
		Db     Queryer
		UserID entity.UserID
	}
	mock.lockGetBalanceByUserID.RLock()
	calls = mock.calls.GetBalanceByUserID
	mock.lockGetBalanceByUserID.RUnlock()
	return calls
}

// GetBalanceTransListByBalanceID calls GetBalanceTransListByBalanceIDFunc.
func (mock *BalanceDetailsGetterRepoMock) GetBalanceTransListByBalanceID(ctx context.Context, db Queryer, balanceID entity.BalanceID) ([]*entity.BalanceTrans, error) {
	if mock.GetBalanceTransListByBalanceIDFunc == nil {
		panic("BalanceDetailsGetterRepoMock.GetBalanceTransListByBalanceIDFunc: method is nil but BalanceDetailsGetterRepo.GetBalanceTransListByBalanceID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Db        Queryer
		BalanceID entity.BalanceID
	}{
		Ctx:       ctx,
		Db:        db,
		BalanceID: balanceID,
	}
	mock.lockGetBalanceTransListByBalanceID.Lock()
	mock.calls.GetBalanceTransListByBalanceID = append(mock.calls.GetBalanceTransListByBalanceID, callInfo)
	mock.lockGetBalanceTransListByBalanceID.Unlock()
	return mock.GetBalanceTransListByBalanceIDFunc(ctx, db, balanceID)
}

// GetBalanceTransListByBalanceIDCalls gets all the calls that were made to GetBalanceTransListByBalanceID.
// Check the length with:
//
//	len(mockedBalanceDetailsGetterRepo.GetBalanceTransListByBalanceIDCalls())
func (mock *BalanceDetailsGetterRepoMock) GetBalanceTransListByBalanceIDCalls() []struct {
	Ctx       context.Context
	Db        Queryer
	BalanceID entity.BalanceID
} {
	var calls []struct {
		Ctx       context.Context
		Db        Queryer
		BalanceID entity.BalanceID
	}
	mock.lockGetBalanceTransListByBalanceID.RLock()
	calls = mock.calls.GetBalanceTransListByBalanceID
	mock.lockGetBalanceTransListByBalanceID.RUnlock()
	return calls
}
